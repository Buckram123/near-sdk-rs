# Workspaces Migration Guide
TODO: write about context, why simtests was not suitable as a testing framework and how workspaces is different

## Transitioning existing near-sdk-sim powered tests to workspaces
As an example, let's take a look at transitioning from near-sdk-sim `4.0.0-pre.6` to workspaces `0.1.1`. Given that near-sdk-sim is going to be deprecated, it is very unlikely that its API is going to ever change, but future releases of workspaces might. Hopefully this guide is going to be helpful even if you are migrating your project to a more recent version, but, if so, keep in mind that the provided snippets might not work as is, in which case refer to workspaces release notes to see how public API has changed since `0.1.1`.

### Async runtime and error handling
Chances are your tests look something like this:
```rust
#[test]
fn simulate_transfer() {
    ...
}
```

First big change is that workspaces API is asynchronous, meaning that contract function calls return values that implement `Future` trait. You will not be able to operate on the call results in a synchronous environment, thus you will have to add an async runtime (if you do not already have one). In this guide we are going to be using `tokio`, but you should be able to use any other alternative. Rewrite the test above like this:

```rust
#[tokio::test]
async fn simulate_transfer() {
    ...
}
```

The second change is that workspaces makes an extensive use of [`anyhow::Result`](https://docs.rs/anyhow/latest/anyhow/type.Result.html). Although you can work with `Result` directly, our recommendation is to make your tests return `anyhow::Result<()>` like this:

```rust
#[tokio::test]
async fn simulate_transfer() -> anyhow::Result<()> {
    ...
}
```

This way you can use `?` anywhere inside the test to safely unpack any `anyhow::Result<R>` type to `R` (will be very useful further down the guide). Note that the test will fail if `anyhow::Result<R>` cannot be unpacked.

### Initialization and deploying contracts
Unlike near-sdk-sim, workspaces spins up an actual NEAR node instance and makes all calls through it. If you are just interested in local development and testing, you need to instantiate a [sandbox](https://github.com/near/sandbox) _worker_, otherwise consider using a testnet or a mainnet worker. Thus, we need to replace simulator initialization that looked like this:

```rust
let root = near_sdk_sim::init_simulator(...);
```

with this:

```rust
let worker = workspaces::sandbox(); // or workspaces::testnet() / workspaces::mainnet()
```

Once you have a worker instance, you can deploy a contract from a WASM file:

```rust
let contract = worker.dev_deploy(include_bytes!("path-to-contract.wasm").to_vec()).await?;
```

Note that unlike `call!` macro from near-sdk-sim, you cannot specify an initialization method for `Worker::dev_deploy`. You will have to call the method yourself using one of the method described in the next section. One other difference is that workspaces is not aware of the contract API, hence you cannot pass the contract struct generated by `#[near_bindgen]`. As you will see in the following section, this makes the API a bit more difficult to use as you are losing the static type checking you were getting with near-sdk-sim. NEAR is aware of this issue, and we are working on making this experience smoother. 

### Making transactions and view calls
Workspaces have a unified way of making all types of calls via a [builder](https://doc.rust-lang.org/1.0.0/style/ownership/builders.html) pattern. Generally, calls are constructed by following these steps:

1. Create a `CallBuilder` by invoking `Contract::call`
2. Pass function call arguments via `CallBuilder::args_json` or `CallBuilder::args_borsh`
3. Configure gas and deposit (if needed) via `CallBuilder::gas` and `CallBuilder::deposit`
4. Finalize the call by consuming builder via `CallBuilder::transaction` or `CallBuilder::view` depending on what kind of call you want to make

Reference these examples for migrating your own calls:

```rust
/*
 * Example 1: A transaction call with deposit
 */
call!(
    root,
    nft.nft_approve(TOKEN_ID.into(), alice.account_id(), None),
    deposit = 170000000000000000000
);

// `contract` is a previously deployed `Contract`
contract
    .call(&worker, "nft_approve")
    .args_json((TOKEN_ID, alice.id(), Option::<String>::None))?
    // Set prepaid gas to 300 TGas (the max amount) if you do not care
    // about gas usage and just want to test the function logic
    .gas(300_000_000_000_000)
    .deposit(170000000000000000000)
    .transact()
    .await?;

/*
 * Example 2: A view call with a single argument
 */
view!(nft.nft_token(TOKEN_ID.into()));

contract
    .call(&worker, "nft_token")
    .args_json((TOKEN_ID,))?
    .view()
    .await?;
```

Note that you have to pass arguments as any serializable type representing a sequential list. Tuples are usually the best candidate due to their heterogeneous nature (remember that you can construct a unary tuple by placing a comma before the closing bracket like this: `(el,)`).

## Caveats
### Batched transactions
### Custom genesis
### Inspecting logs
